/**************************************************************************** *   MiniVNC (c) 2022-2024 Marcio Teixeira                                  * *                                                                          * *   This program is free software: you can redistribute it and/or modify   * *   it under the terms of the GNU General Public License as published by   * *   the Free Software Foundation, either version 3 of the License, or      * *   (at your option) any later version.                                    * *                                                                          * *   This program is distributed in the hope that it will be useful,        * *   but WITHOUT ANY WARRANTY; without even the implied warranty of         * *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          * *   GNU General Public License for more details.                           * *                                                                          * *   To view a copy of the GNU General Public License, go to the following  * *   location: <http://www.gnu.org/licenses/>.                              * ****************************************************************************/#include <Files.h>#include "VNCServer.h"#include "VNCEncoder.h"#include "TightVNCSupport.h"#include "DebugLog.h"#if USE_TIGHT_AUTHextern "C" {    extern struct TightVNCServerAuthCaps tightAuthCaps;    extern struct TightVNCServerInitCaps tightInitCaps;}pascal void tcpSendTightVNCTunnelTypes(TCPiopb *pb);pascal void tcpGetTightVncTunnelChoice(TCPiopb *pb);pascal void tcpGetTightVncAuthChoice(TCPiopb *pb);pascal void tcpProcessTightVncAuthChoice(TCPiopb *pb);pascal void tightVNCMessageFinished(TCPiopb *pb);void loadTightSupport() {    dprintf("Loading Tight Authentication support\n");}void sendTightCapabilities() {    if (vncFlags.useTightAuth) {        dprintf("Sending TightVNC capabilities\n");        myWDS[1].ptr = (Ptr) &tightInitCaps;        myWDS[1].length = sizeof(unsigned short) * 4 + sizeof(TightVNCCapabilites) *            (tightInitCaps.numberOfServerMesg + tightInitCaps.numberOfClientMesg + tightInitCaps.numberOfEncodings);        myWDS[2].ptr = 0;        myWDS[2].length = 0;    }}pascal void tcpSendTightVNCAuthTypes(TCPiopb *pb) {    if (tcpSuccess(pb)) {        vncFlags.useTightAuth = true;        tcp.then(pb, tcpGetTightVncAuthChoice);        myWDS[0].ptr = (Ptr) &tightAuthCaps;        myWDS[0].length = sizeof(TightVNCServerAuthCaps);        tcp.send(pb, stream, myWDS, kTimeOut, true);    }}pascal void tcpGetTightVncAuthChoice(TCPiopb *pb) {    if (tcpSuccess(pb)) {        tcp.then(pb, tcpProcessTightVncAuthChoice);        tcp.receive(pb, stream, (Ptr) &vncClientMessage, sizeof(TightVNCCapReply));    }}pascal void tcpProcessTightVncAuthChoice(TCPiopb *pb) {    if (tcpSuccess(pb)) {        #ifdef VNC_DEBUG            dprintf("Tight auth choice: %ld\n", vncClientMessage.tightCapReq.code);        #endif        switch (vncClientMessage.tightCapReq.code) {            case mNoAuthentication:                tcpSendAuthResult(pb);                break;            case mVNCAuthentication:                tcpSendAuthChallenge(pb);                break;        }    }}void tightVNCSendReply(Ptr ptr, size_t length);void tightVNCSendReply(Ptr ptr, size_t length) {    vncFlags.fbUpdateInProgress = true;    myWDS[0].ptr = ptr;    myWDS[0].length = length;    myWDS[1].ptr = 0;    myWDS[1].length = 0;    TCPiopb *pb = &epb_send.pb;    tcp.then(pb, tightVNCMessageFinished);    tcp.send(pb, stream, myWDS, kTimeOut, false);}pascal void tightVNCMessageFinished(TCPiopb *pb);pascal void tightVNCMessageFinished(TCPiopb *pb) {    if (tcpSuccess(pb)) {        dprintf("==== Finishing deferred messages ====\n");        vncFlags.fbUpdateInProgress = false;        returnFromTightVNCMessage();    }}// Convert from Mac epoch time (seconds since midnight January 1st, 1904)// to UNIX epoch time (seconds since midnight January 1st, 1970) in milisecondsstatic asm void macToUnixEpoch(uint64*) {    machine 68020    #define tdArg       8(a6)    #define tdPtr         a0    #define tdLo          d0    #define tdHi          d1    #define tmp           d2    link    a6,#0000             // Link for debugger    move.l tdArg,tdPtr    move.l struct(uint64.lo)(tdPtr),tdLo    move.l struct(uint64.hi)(tdPtr),tdHi    subi.l #2082844800,tdLo    moveq           #0,tmp    subx.l         tmp,tdHi    mulu.l #1000,tdHi:tdLo    move.l tdLo, struct(uint64.lo)(tdPtr)    move.l tdHi, struct(uint64.hi)(tdPtr)    unlk    a6    rts    #undef tdArg    #undef tdPtr    #undef tdLo    #undef tdHi    #undef tmp}#define IN_STREAM_COPY(arg)       inStream.copyTo(&arg, sizeof(arg));#define IN_STREAM_PEEK(arg, len) {size_t avail; arg = inStream.getDataBlock(&avail); if(avail < len) {dprintf("Insufficient data! %ld < %ld\n", avail, len);} inStream.skip(len);}#define OUT_STREAM_COPY(type, arg)      *(type*)c++ = arg;Boolean parseFilePath(const char *dir, Str63 myName, HParamBlockRec *hpb, CInfoPBRec *cpb);Boolean parseFilePath(const char *dir, Str63 myName, HParamBlockRec *hpb, CInfoPBRec *cpb) {    OSErr      myErr = noErr;    hpb->volumeParam.ioCompletion = 0;    hpb->volumeParam.ioNamePtr    = myName;    hpb->volumeParam.ioVolIndex   = -1;    hpb->volumeParam.ioVRefNum    = 0;    cpb->dirInfo.ioCompletion     = 0;    cpb->dirInfo.ioNamePtr        = myName;    cpb->dirInfo.ioVRefNum        = 0;    cpb->dirInfo.ioFDirIndex      = 0;    cpb->dirInfo.ioDrDirID        = 2; // 0 = working dir; 2 = root dir    const Boolean isRoot = dir[0] == '/' && dir[1] == '\0';    if (!isRoot) {        // Walk the path, on exit ioVRefNum and ioDrDirID will be populated in myCPB        const char *c;        do {            dir++; // Skip the leading slash            c = dir;            while ((*c != '\0') && (*c != '/')) c++;            myName[0] = c - dir;            BlockMove (dir, myName + 1, myName[0]);            if (hpb->volumeParam.ioVRefNum == 0) {                // Append color to make it into a full pathname                myName[0]++;                myName[myName[0]] = ':';                // Convert it to a volume reference number                myErr = PBHGetVInfo(hpb, false);                cpb->dirInfo.ioVRefNum = hpb->volumeParam.ioVRefNum;            } else {                myErr = PBGetCatInfo(cpb, false);            }            if (*c == 0) break;            dir = c;        } while (dir[0] != '\0');    }    return isRoot;}void tightVNCFileList(MessageData *pb);void tightVNCFileList(MessageData *pb) {    /**        Message Format:            long           message;            unsigned char  compressionLevel;            unsigned long  dirNameSize;        Followed by char Dirname[dirNameSize]     */    TightVNCFileUploadData &req = vncClientMessage.tightFileUploadData;    const char *dir;    IN_STREAM_COPY(req.message);    IN_STREAM_COPY(req.compressionLevel);    IN_STREAM_COPY(req.fNameSize);    IN_STREAM_PEEK(dir, req.fNameSize);    dprintf("Got file list request: %.*s\n", (unsigned short) req.fNameSize, dir);    // Get the GMT conversion factor (this function cannot be called from an interrupt)    MachineLocation loc;    ReadLocation(&loc);    const long gmtDelta = (loc.u.gmtDelta & 0x00FFFFFF) | ((loc.u.gmtDelta & (1L << 23)) ? 0xFF000000 : 0);    OSErr          myErr;    HParamBlockRec myHPB;    CInfoPBRec     myCPB;    Str63          myName;    Boolean isRoot = parseFilePath(dir, myName, &myHPB, &myCPB);    //const int vRefNum     = 0;    const long dirId      = myCPB.dirInfo.ioDrDirID;    const char kFolderBit = 4;    // Fill out the header    unsigned char *c = (unsigned char *)fbUpdateBuffer;    unsigned char *end = fbUpdateBuffer + GetPtrSize((Ptr)fbUpdateBuffer);    myHPB.volumeParam.ioVolIndex   = 1;    myCPB.dirInfo.ioFDirIndex      = 1;    myCPB.dirInfo.ioDrDirID        = dirId;    // Make space for the header    c += sizeof(TightVNCFileListReply); // Skip the header    c += sizeof(unsigned long);         // Skip the number of files    for (;;) {        if (isRoot) {            // List volumes            myErr = PBHGetVInfo(&myHPB, false);            myHPB.volumeParam.ioVolIndex++;        } else {            // List files and folders            myCPB.dirInfo.ioDrDirID = dirId;            myErr = PBGetCatInfo(&myCPB, false);            myCPB.dirInfo.ioFDirIndex++;        }        if (myErr != noErr) {            break;        }        const Boolean isDir = isRoot || (myCPB.dirInfo.ioFlAttrib && (1 << kFolderBit));        uint64 modTime, fileSize;        if (isDir) {            modTime.hi = 0;            modTime.lo = myHPB.volumeParam.ioVLsMod - gmtDelta;            fileSize.hi = 0;            fileSize.lo = 0;        } else {            modTime.hi = 0;            modTime.lo = myCPB.hFileInfo.ioFlMdDat - gmtDelta;            fileSize.hi = 0;            fileSize.lo = myCPB.hFileInfo.ioFlLgLen + myCPB.hFileInfo.ioFlRLgLen;        }        macToUnixEpoch(&modTime);        // Append the record to the reply        if ((end - c) < (sizeof(TightVNCFileListEntry) + myName[0])) {            dprintf("Insufficient buffer space to list all files!\n");            break;        }        ((TightVNCFileListEntry *)c)->lastModified = modTime;        ((TightVNCFileListEntry *)c)->fileSize = fileSize;        ((TightVNCFileListEntry *)c)->flags = isDir ? 1 : 0;        ((TightVNCFileListEntry *)c)->dirNameSize = myName[0];        c += sizeof(TightVNCFileListEntry);        BlockMove(myName + 1, c, myName[0]);        c += myName[0];    }    end = c;    const size_t uncompressedLength = (end - fbUpdateBuffer) - sizeof(TightVNCFileListReply);    // Write out the header    c = (unsigned char *)fbUpdateBuffer;    ((TightVNCFileListReply *)c)->message          = 0xFC000103;    ((TightVNCFileListReply *)c)->compressionLevel = 0;    ((TightVNCFileListReply *)c)->compressedSize   = uncompressedLength;    ((TightVNCFileListReply *)c)->uncompressedSize = uncompressedLength;    c += sizeof(TightVNCFileListReply);    // Write out the file count    *((unsigned long *)c) = (isRoot ? myHPB.volumeParam.ioVolIndex : myCPB.dirInfo.ioFDirIndex) - 2;    tightVNCSendReply((Ptr) fbUpdateBuffer, end - fbUpdateBuffer);}void tightVNCFileUploadStart(MessageData *pb);void tightVNCFileUploadStart(MessageData *pb) {    /**        Message Format:            unsigned long  message;            unsigned long  fNameSize;            const char    *filename; // char filename[fNameSize]            unsigned char  uploadFlags;            uint64         initialOffset;     */    TightVNCFileUploadData &req = vncClientMessage.tightFileUploadData;    IN_STREAM_COPY(req.message);    IN_STREAM_COPY(req.fNameSize);    IN_STREAM_PEEK(req.filename, req.fNameSize);    IN_STREAM_COPY(req.uploadFlags);    IN_STREAM_COPY(req.initialOffset);    dprintf("Got file upload start request: %.*s\n", (unsigned short)req.fNameSize, req.filename);    // Open the file for writing    OSErr          myErr;    HParamBlockRec myHPB;    CInfoPBRec     myCPB;    Str63          myName;    Boolean isRoot = parseFilePath(req.filename, myName, &myHPB, &myCPB);    OSErr err = HCreate(myHPB.volumeParam.ioVRefNum, myCPB.dirInfo.ioDrDirID, myName, 'TEXT', 'TEXT');    if (err != noErr) {        dprintf("Unable to create file %d, %d, %#p\n", myHPB.volumeParam.ioVRefNum, myCPB.dirInfo.ioDrDirID, myName);    }    err = HOpenDF(myHPB.volumeParam.ioVRefNum, myCPB.dirInfo.ioDrDirID, myName, fsWrPerm, &req.fRefNum);    if (err != noErr) {        dprintf("Unable to open file\n");    }    // Write out the reply    unsigned char *c = fbUpdateBuffer;    OUT_STREAM_COPY(unsigned long, 0xFC000107);    tightVNCSendReply((Ptr) fbUpdateBuffer, sizeof(unsigned long));}pascal void tightVNCFileUploadDataFragment(TCPiopb *pb);pascal void tightVNCFileUploadBuffersReturned(TCPiopb *pb);pascal void tightVNCFileUploadBuffersFilled(TCPiopb *pb);void tightVNCFileUploadData(MessageData *pb);void tightVNCFileUploadData(MessageData *pb) {    /**        Message Format:            unsigned char  compressionLevel;            size_t         compressedSize;            size_t         uncompressedSize;        Followed by File[compressedSize],            but if (realSize = compressedSize = 0) followed by uint32_t modTime     */    TightVNCFileUploadData &req = vncClientMessage.tightFileUploadData;    IN_STREAM_COPY(req.message);    IN_STREAM_COPY(req.compressionLevel);    IN_STREAM_COPY(req.compressedSize);    IN_STREAM_COPY(req.uncompressedSize);    dprintf("Got file data (decompress: %ld => %ld)\n", req.compressedSize, req.uncompressedSize);    tightVNCFileUploadDataFragment(&epb_recv.pb);}pascal void tightVNCFileUploadDataFragment(TCPiopb *pb) {    TightVNCFileUploadData &req = vncClientMessage.tightFileUploadData;    while (req.compressedSize > 0) {        size_t avail;        const char *data = inStream.getDataBlock(&avail);        const size_t bytesRead = min(avail, req.compressedSize);        inStream.skip(bytesRead);        req.compressedSize -= bytesRead;        long bytesWritten = bytesRead;        OSErr err = FSWrite(req.fRefNum, &bytesWritten, data);        if (err != noErr) {            dprintf("Unable to write file data\n");        }        if (inStream.finished()) {            // Return the buffers            tcp.then(pb, tightVNCFileUploadBuffersReturned);            tcp.receiveReturnBuffers(pb);            return;        }    }    // Write out the reply    unsigned char *c = fbUpdateBuffer;    OUT_STREAM_COPY(unsigned long, 0xFC000109);    tightVNCSendReply((Ptr) fbUpdateBuffer, sizeof(unsigned long));}pascal void tightVNCFileUploadBuffersReturned(TCPiopb *pb) {    if (tcpSuccess(pb)) {        tcp.then(pb, tightVNCFileUploadBuffersFilled);        tcp.receiveNoCopy(pb, stream, myRDS, kNumRDS);    }}pascal void tightVNCFileUploadBuffersFilled(TCPiopb *pb) {    if (tcpSuccess(pb)) {        inStream.setPosition(0);        tightVNCFileUploadDataFragment(pb);    }}void tightVNCFileUploadEnd(MessageData *pb);void tightVNCFileUploadEnd(MessageData *pb) {    /**        Message Format:            long           message;            unsigned short flags;            uint64         lastModified;     */    TightVNCFileUploadData &req = vncClientMessage.tightFileUploadData;    IN_STREAM_COPY(req.message);    IN_STREAM_COPY(req.fileFlags);    IN_STREAM_COPY(req.modificationTime);    dprintf("Got file end\n");    // Close the file    OSErr err = FSClose(req.fRefNum);    // Write out the header    unsigned char *c = fbUpdateBuffer;    OUT_STREAM_COPY(unsigned long, 0xFC00010B);    tightVNCSendReply((Ptr) fbUpdateBuffer, sizeof(unsigned long));}DispatchMsgResult dispatchTightClientMessage(MessageData *pb) {    READ_ALL(tightVncExtMsg);    MAIN_LOOP_ONLY();    switch (pb->msgPtr->tightVncExtMsg) {        case 0xFC000102:            tightVNCFileList(pb);            break;        case 0xFC000106:            tightVNCFileUploadStart(pb);            break;        case 0xFC000108:            tightVNCFileUploadData(pb);            break;        case 0xFC00010A:            tightVNCFileUploadEnd(pb);            break;        default:            dprintf("Invalid TightVNC message: %ld\n", pb->msgPtr->tightVncExtMsg);            vncState = VNC_ERROR;            break;    }    return returnToCaller;}#endif // USE_TIGHT_AUTH